//
//  basicshooter.cpp
//  Hoshizora
//
//  Created by Robert Bu on 9/2/11.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
#include "basicshooter.h"

#include "bullet/bullet.h"
#include "base/enemy.h"
#include "base/Tower.h"
#include "bulletFactory.h"

#include "components/Sensor.h"

namespace atd {
    
    BasicShooter::BasicShooter(SoraLightWeightEntity* owner, const std::string& bulletType):
    SoraComponent(owner, false),
    mObject(0),
    mBulletType(bulletType),
    mPrevDelta(0.f) {
        mShootUpdater.setInterval(1.f);
    }
    
    const BasicShooter::BulletCont& BasicShooter::getBullets() const {
        return mBullets;
    }
    
    void BasicShooter::onMessage(SoraMessageEvent* evt) {
        SoraString message = evt->getMessage();
        if(message == SID_EVENT_ENEMY_ENTER) {
            onEnemyEnter(evt->getData<Enemy*>());
        } else if(message == SID_EVENT_ENEMY_DEATH) {
            onEnemyDied(evt->getData<Enemy*>());
        } else if(message == SID_EVENT_ENEMY_LEAVE) {
            onEnemyLeave(evt->getData<Enemy*>());
        }
    }
    
    void BasicShooter::shootBullet() {
        if(getEnemy() != 0) {
            Object* obj = static_cast<Object*>(getOwner());
            Bullet* bullet = BulletFactory::Instance().createBullet(mBulletType, obj->getPosition(), mObject, mAttack.getAttack());
            if(bullet) {
                // notify other components to modify the bullet
                SoraMessageEvent evt(SID_EVENT_BULLET_SHOOT, bullet);
                // evt.setSource(getOwner())
                
                getOwner()->sendMessageT(&evt);
                
                mBullets.push_back(bullet);
            }
        }
    }
    
    
    void BasicShooter::onUpdate(float dt) {
        if(mShootUpdater.update(dt))
            shootBullet();
        
        mPrevDelta = dt;
    }
    
    void BasicShooter::onRender() {
        BulletCont::iterator it = mBullets.begin();
        BulletCont::iterator end = mBullets.end();
        while(it != end) {
            Bullet* bullet = *it;
            bullet->update(mPrevDelta);
            bullet->render();
            
            if(bullet->isDead()) {
                delete bullet;
                it = mBullets.erase(it);
                continue;
            }
            ++it;
        }
    }
    
    void BasicShooter::onEnemyEnter(Enemy* enemy) {
        if(!mObject)
            mObject = enemy;
    }
    
    void BasicShooter::onEnemyDied(Enemy* enemy) {
        mObject = NULL;

        Sensor* sensor = ComponentCast<Sensor>(getOwner()->getComponent("Sensor"));
        if(sensor) {
            mObject = sensor->pickLastEnemy();
        }
    }
    
    void BasicShooter::onEnemyLeave(Enemy* enemy) {
        mObject = 0;
    }
    
    void BasicShooter::setEnemy(Enemy* enemy) {
        mObject = enemy;
    }
    
    Enemy* BasicShooter::getEnemy() const {
        return mObject;
    }
    
    void BasicShooter::setBulletType(const std::string& type) {
        mBulletType = type;
    }
    
    std::string BasicShooter::getBulletType() const {
        return mBulletType;
    }
    
    void BasicShooter::setAttack(const Attack& atk) {
        mAttack = atk;
    }
    
    const Attack& BasicShooter::getAttack() const {
        return mAttack;
    }
    
    void BasicShooter::setShootInterval(float interval) {
        mShootUpdater.setInterval(interval);
    }
    
    float BasicShooter::getShootInterval() const {
        return mShootUpdater.getInterval();
    }
    
} // namespace atd
